// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.1
// source: pkg/grpc/protos/upload_service.proto

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UploadService_AddTask_FullMethodName         = "/syncreve.UploadService/AddTask"
	UploadService_AddBatchTasks_FullMethodName   = "/syncreve.UploadService/AddBatchTasks"
	UploadService_CancelTask_FullMethodName      = "/syncreve.UploadService/CancelTask"
	UploadService_GetTaskInfo_FullMethodName     = "/syncreve.UploadService/GetTaskInfo"
	UploadService_ListTasks_FullMethodName       = "/syncreve.UploadService/ListTasks"
	UploadService_WatchTaskStatus_FullMethodName = "/syncreve.UploadService/WatchTaskStatus"
	UploadService_PauseTask_FullMethodName       = "/syncreve.UploadService/PauseTask"
	UploadService_ResumeTask_FullMethodName      = "/syncreve.UploadService/ResumeTask"
	UploadService_RetryTask_FullMethodName       = "/syncreve.UploadService/RetryTask"
	UploadService_ClearCompleted_FullMethodName  = "/syncreve.UploadService/ClearCompleted"
	UploadService_GetStats_FullMethodName        = "/syncreve.UploadService/GetStats"
)

// UploadServiceClient is the client API for UploadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// UploadService provides file upload management
type UploadServiceClient interface {
	// Add upload task
	AddTask(ctx context.Context, in *AddUploadTaskRequest, opts ...grpc.CallOption) (*AddUploadTaskResponse, error)
	// Add batch upload tasks
	AddBatchTasks(ctx context.Context, in *AddBatchUploadTasksRequest, opts ...grpc.CallOption) (*AddUploadTaskResponse, error)
	// Cancel upload task
	CancelTask(ctx context.Context, in *CancelUploadTaskRequest, opts ...grpc.CallOption) (*CancelUploadTaskResponse, error)
	// Get upload task info
	GetTaskInfo(ctx context.Context, in *GetUploadTaskInfoRequest, opts ...grpc.CallOption) (*UploadTaskInfoResponse, error)
	// List upload tasks
	ListTasks(ctx context.Context, in *ListUploadTasksRequest, opts ...grpc.CallOption) (*ListUploadTasksResponse, error)
	// Get task status stream
	WatchTaskStatus(ctx context.Context, in *WatchUploadTaskStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[UploadTaskStatusUpdate], error)
	// Pause upload task
	PauseTask(ctx context.Context, in *PauseUploadTaskRequest, opts ...grpc.CallOption) (*PauseUploadTaskResponse, error)
	// Resume upload task
	ResumeTask(ctx context.Context, in *ResumeUploadTaskRequest, opts ...grpc.CallOption) (*ResumeUploadTaskResponse, error)
	// Retry failed task
	RetryTask(ctx context.Context, in *RetryUploadTaskRequest, opts ...grpc.CallOption) (*RetryUploadTaskResponse, error)
	// Clear completed tasks
	ClearCompleted(ctx context.Context, in *ClearUploadCompletedRequest, opts ...grpc.CallOption) (*ClearUploadCompletedResponse, error)
	// Get upload statistics
	GetStats(ctx context.Context, in *GetUploadStatsRequest, opts ...grpc.CallOption) (*UploadStatsResponse, error)
}

type uploadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUploadServiceClient(cc grpc.ClientConnInterface) UploadServiceClient {
	return &uploadServiceClient{cc}
}

func (c *uploadServiceClient) AddTask(ctx context.Context, in *AddUploadTaskRequest, opts ...grpc.CallOption) (*AddUploadTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddUploadTaskResponse)
	err := c.cc.Invoke(ctx, UploadService_AddTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) AddBatchTasks(ctx context.Context, in *AddBatchUploadTasksRequest, opts ...grpc.CallOption) (*AddUploadTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddUploadTaskResponse)
	err := c.cc.Invoke(ctx, UploadService_AddBatchTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) CancelTask(ctx context.Context, in *CancelUploadTaskRequest, opts ...grpc.CallOption) (*CancelUploadTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelUploadTaskResponse)
	err := c.cc.Invoke(ctx, UploadService_CancelTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) GetTaskInfo(ctx context.Context, in *GetUploadTaskInfoRequest, opts ...grpc.CallOption) (*UploadTaskInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadTaskInfoResponse)
	err := c.cc.Invoke(ctx, UploadService_GetTaskInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) ListTasks(ctx context.Context, in *ListUploadTasksRequest, opts ...grpc.CallOption) (*ListUploadTasksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUploadTasksResponse)
	err := c.cc.Invoke(ctx, UploadService_ListTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) WatchTaskStatus(ctx context.Context, in *WatchUploadTaskStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[UploadTaskStatusUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &UploadService_ServiceDesc.Streams[0], UploadService_WatchTaskStatus_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchUploadTaskStatusRequest, UploadTaskStatusUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type UploadService_WatchTaskStatusClient = grpc.ServerStreamingClient[UploadTaskStatusUpdate]

func (c *uploadServiceClient) PauseTask(ctx context.Context, in *PauseUploadTaskRequest, opts ...grpc.CallOption) (*PauseUploadTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PauseUploadTaskResponse)
	err := c.cc.Invoke(ctx, UploadService_PauseTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) ResumeTask(ctx context.Context, in *ResumeUploadTaskRequest, opts ...grpc.CallOption) (*ResumeUploadTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResumeUploadTaskResponse)
	err := c.cc.Invoke(ctx, UploadService_ResumeTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) RetryTask(ctx context.Context, in *RetryUploadTaskRequest, opts ...grpc.CallOption) (*RetryUploadTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RetryUploadTaskResponse)
	err := c.cc.Invoke(ctx, UploadService_RetryTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) ClearCompleted(ctx context.Context, in *ClearUploadCompletedRequest, opts ...grpc.CallOption) (*ClearUploadCompletedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearUploadCompletedResponse)
	err := c.cc.Invoke(ctx, UploadService_ClearCompleted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) GetStats(ctx context.Context, in *GetUploadStatsRequest, opts ...grpc.CallOption) (*UploadStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadStatsResponse)
	err := c.cc.Invoke(ctx, UploadService_GetStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UploadServiceServer is the server API for UploadService service.
// All implementations must embed UnimplementedUploadServiceServer
// for forward compatibility.
//
// UploadService provides file upload management
type UploadServiceServer interface {
	// Add upload task
	AddTask(context.Context, *AddUploadTaskRequest) (*AddUploadTaskResponse, error)
	// Add batch upload tasks
	AddBatchTasks(context.Context, *AddBatchUploadTasksRequest) (*AddUploadTaskResponse, error)
	// Cancel upload task
	CancelTask(context.Context, *CancelUploadTaskRequest) (*CancelUploadTaskResponse, error)
	// Get upload task info
	GetTaskInfo(context.Context, *GetUploadTaskInfoRequest) (*UploadTaskInfoResponse, error)
	// List upload tasks
	ListTasks(context.Context, *ListUploadTasksRequest) (*ListUploadTasksResponse, error)
	// Get task status stream
	WatchTaskStatus(*WatchUploadTaskStatusRequest, grpc.ServerStreamingServer[UploadTaskStatusUpdate]) error
	// Pause upload task
	PauseTask(context.Context, *PauseUploadTaskRequest) (*PauseUploadTaskResponse, error)
	// Resume upload task
	ResumeTask(context.Context, *ResumeUploadTaskRequest) (*ResumeUploadTaskResponse, error)
	// Retry failed task
	RetryTask(context.Context, *RetryUploadTaskRequest) (*RetryUploadTaskResponse, error)
	// Clear completed tasks
	ClearCompleted(context.Context, *ClearUploadCompletedRequest) (*ClearUploadCompletedResponse, error)
	// Get upload statistics
	GetStats(context.Context, *GetUploadStatsRequest) (*UploadStatsResponse, error)
	mustEmbedUnimplementedUploadServiceServer()
}

// UnimplementedUploadServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUploadServiceServer struct{}

func (UnimplementedUploadServiceServer) AddTask(context.Context, *AddUploadTaskRequest) (*AddUploadTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTask not implemented")
}
func (UnimplementedUploadServiceServer) AddBatchTasks(context.Context, *AddBatchUploadTasksRequest) (*AddUploadTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddBatchTasks not implemented")
}
func (UnimplementedUploadServiceServer) CancelTask(context.Context, *CancelUploadTaskRequest) (*CancelUploadTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTask not implemented")
}
func (UnimplementedUploadServiceServer) GetTaskInfo(context.Context, *GetUploadTaskInfoRequest) (*UploadTaskInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTaskInfo not implemented")
}
func (UnimplementedUploadServiceServer) ListTasks(context.Context, *ListUploadTasksRequest) (*ListUploadTasksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTasks not implemented")
}
func (UnimplementedUploadServiceServer) WatchTaskStatus(*WatchUploadTaskStatusRequest, grpc.ServerStreamingServer[UploadTaskStatusUpdate]) error {
	return status.Errorf(codes.Unimplemented, "method WatchTaskStatus not implemented")
}
func (UnimplementedUploadServiceServer) PauseTask(context.Context, *PauseUploadTaskRequest) (*PauseUploadTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseTask not implemented")
}
func (UnimplementedUploadServiceServer) ResumeTask(context.Context, *ResumeUploadTaskRequest) (*ResumeUploadTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeTask not implemented")
}
func (UnimplementedUploadServiceServer) RetryTask(context.Context, *RetryUploadTaskRequest) (*RetryUploadTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetryTask not implemented")
}
func (UnimplementedUploadServiceServer) ClearCompleted(context.Context, *ClearUploadCompletedRequest) (*ClearUploadCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearCompleted not implemented")
}
func (UnimplementedUploadServiceServer) GetStats(context.Context, *GetUploadStatsRequest) (*UploadStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStats not implemented")
}
func (UnimplementedUploadServiceServer) mustEmbedUnimplementedUploadServiceServer() {}
func (UnimplementedUploadServiceServer) testEmbeddedByValue()                       {}

// UnsafeUploadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UploadServiceServer will
// result in compilation errors.
type UnsafeUploadServiceServer interface {
	mustEmbedUnimplementedUploadServiceServer()
}

func RegisterUploadServiceServer(s grpc.ServiceRegistrar, srv UploadServiceServer) {
	// If the following call pancis, it indicates UnimplementedUploadServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UploadService_ServiceDesc, srv)
}

func _UploadService_AddTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUploadTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).AddTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_AddTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).AddTask(ctx, req.(*AddUploadTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_AddBatchTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddBatchUploadTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).AddBatchTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_AddBatchTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).AddBatchTasks(ctx, req.(*AddBatchUploadTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_CancelTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelUploadTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).CancelTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_CancelTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).CancelTask(ctx, req.(*CancelUploadTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_GetTaskInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUploadTaskInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).GetTaskInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_GetTaskInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).GetTaskInfo(ctx, req.(*GetUploadTaskInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_ListTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUploadTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).ListTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_ListTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).ListTasks(ctx, req.(*ListUploadTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_WatchTaskStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchUploadTaskStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UploadServiceServer).WatchTaskStatus(m, &grpc.GenericServerStream[WatchUploadTaskStatusRequest, UploadTaskStatusUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type UploadService_WatchTaskStatusServer = grpc.ServerStreamingServer[UploadTaskStatusUpdate]

func _UploadService_PauseTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseUploadTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).PauseTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_PauseTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).PauseTask(ctx, req.(*PauseUploadTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_ResumeTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeUploadTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).ResumeTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_ResumeTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).ResumeTask(ctx, req.(*ResumeUploadTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_RetryTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetryUploadTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).RetryTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_RetryTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).RetryTask(ctx, req.(*RetryUploadTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_ClearCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearUploadCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).ClearCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_ClearCompleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).ClearCompleted(ctx, req.(*ClearUploadCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_GetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUploadStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).GetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_GetStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).GetStats(ctx, req.(*GetUploadStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UploadService_ServiceDesc is the grpc.ServiceDesc for UploadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UploadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "syncreve.UploadService",
	HandlerType: (*UploadServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddTask",
			Handler:    _UploadService_AddTask_Handler,
		},
		{
			MethodName: "AddBatchTasks",
			Handler:    _UploadService_AddBatchTasks_Handler,
		},
		{
			MethodName: "CancelTask",
			Handler:    _UploadService_CancelTask_Handler,
		},
		{
			MethodName: "GetTaskInfo",
			Handler:    _UploadService_GetTaskInfo_Handler,
		},
		{
			MethodName: "ListTasks",
			Handler:    _UploadService_ListTasks_Handler,
		},
		{
			MethodName: "PauseTask",
			Handler:    _UploadService_PauseTask_Handler,
		},
		{
			MethodName: "ResumeTask",
			Handler:    _UploadService_ResumeTask_Handler,
		},
		{
			MethodName: "RetryTask",
			Handler:    _UploadService_RetryTask_Handler,
		},
		{
			MethodName: "ClearCompleted",
			Handler:    _UploadService_ClearCompleted_Handler,
		},
		{
			MethodName: "GetStats",
			Handler:    _UploadService_GetStats_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchTaskStatus",
			Handler:       _UploadService_WatchTaskStatus_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/grpc/protos/upload_service.proto",
}
